#!/usr/bin/python3

import sys
import os
import argparse
from libstu import *
from pprint import pprint
from copy import deepcopy
import itertools
import math

THIS = os.path.basename(sys.argv[0])
DEFAULT_INPUT = THIS + "-input"

def main():
    arg_parser = argparse.ArgumentParser(prog=THIS)
    arg_parser.add_argument("-f", "--file", default=DEFAULT_INPUT,
                            help="specify the input file (default: %(default)s)", metavar="file")
    args = arg_parser.parse_args()

    # Open input file

    input_path = os.path.abspath(args.file)
    if not os.path.exists(input_path):
        print("%s: Error: File '%s' not found" % (THIS, args.file))
        return 1

    input = open(input_path, "r")
    if input is None:
        print("%s: Error: Couldn't open file '%s'" % (THIS, input_path))
        return 1

    # Main loop

    # Parse first line
    seeds = [int(seed) for seed in next(input).split(':')[1].split()]
    #print(seeds)

    next(input)

    def lookup(value, map_name, maps, debug=False):
        log_str = f'{value}:'
        m = maps[map_name]
        log_str += f' {m["dst"]}:'
        while True:
            # dst_start, src_start, r_len
            for dst_start, src_start, r_len in m['ranges']:
                if value < src_start:
                    # Direct mapping
                    log_str += f'd{value}'
                    break
                if src_start <= value < src_start + r_len:
                    # Offset mapping
                    value = dst_start + (value - src_start)
                    log_str += f'o{value}'
                    break
            else:
                log_str += f'D{value}'
            if m['dst'] not in maps:
                break
            m = maps[m['dst']]
            log_str += f' {m["dst"]}:'

        if debug:
            print(log_str)
        return value

    maps = {}
    for line in input:
        line = line.strip()
        if not line:
            m['ranges'].sort(key=lambda x: x[1])
            continue
        if line[-1] == ':':
            src_name, _, dst_name = line.split()[0].split('-')
            m = {'dst': dst_name, 'ranges': []}
            maps[src_name] = m
            continue
        # dst_start, src_start, r_len
        m['ranges'].append([int(i) for i in line.split()])
    m['ranges'].sort(key=lambda x: x[1])
    #pprint(maps)

    min_location = math.inf
    for seed in seeds:
        location = lookup(seed, 'seed', maps)
        if location < min_location:
            min_location = location
    print(f'Part One: {min_location}')

    min_location = math.inf
    for i in range(0, len(seeds), 2):
        for seed in range(seeds[i], seeds[i] + seeds[i+1]):
            print(f'\rrange {i}:{seeds[i]}-{seeds[i]+seeds[i+1]-1} ?{seed}', end='')
            location = lookup(seed, 'seed', maps)
            if location < min_location:
                min_location = location
    print(f'Part Two: {min_location}')

    return 0


if __name__ == "__main__":
    sys.exit(main())
